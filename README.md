# SimpleMutex

`SimpleMutex::Mutex` - Redis-based locks with ability to store custom data inside them.

`SimpleMutex::Job` - class that generates locks for Sidekiq jobs using job's class name and
params if needed.

`SimpleMutex::Batch` - wrapper for Sidekiq Pro batches that use SimpleMutex::Mutex to prevent
running multiple batch instances.

`SimpleMutex::JobCleaner` - cleaner for leftover locks created by SimpleMutex::Job if Sidekiq
dies unexpectedly.

`SimpleMutex::BatchCleaner` - cleaner for leftover lock created by SimpleMutex::Batch if Sidekiq
dies unexpectedly.

`SimpleMutex::Helper` - auxiliary class for debugging purposes. Allows to inspect existing locks.

`SimpleMutex::JobMixin` - mixin for job classes with DSL simplifying usage of `SimpleMutex::Job`

## Configuration

Providing Redis instance before using gem is mandatory.

```ruby
SimpleMutex.redis = Redis.new(
  # ...
)
```

Providing logger is optional (used by Sidekiq::Cleaner).

```ruby
SimpleMutex.logger = Logger.new(
  # ...
)
```

When using gem with Ruby on Rails you can set those in initializers

## SimpleMutex::Mutex Usage

For any code block

```ruby
  SimpleMutex::Mutex.with_lock("some_lock_key") do
    # your code
  end
```

Manually creating and deleting lock

```ruby
  mutex = SimpleMutex::Mutex.new("some_lock_key")
  mutex.lock!
  # your code
  mutex.unlock!
```

If you for some reason don't want exceptions to be raised when obtaining/deleting lock is failed you
can use `non-!` methods.

```ruby
  mutex = SimpleMutex::Mutex.new("some_lock_key")
  mutex.lock # obtaining of lock is not guaranteed
  mutex.locked? # but you can check if it is obtained
  mutex.unlock # releasing of lock is not guaranteed
```

There are lock/lock!/unlock/unlock! methods defined on class if you don't want to use initializer.
But mutexes have random `:signature` stored inside to determine ownership. By default it prevents
deleting locks with signature different from provided. You can use `force: true` to ignore
signature check.

```ruby
  SimpleMutex::Mutex.lock!("some_lock_key", signature: "abra_kadabra")

  # This will work because signature is same as in lock
  SimpleMutex::Mutex.unlock!("some_lock_key", signature: "abra_kadabra")

  # This won't work
  SimpleMutex::Mutex.unlock!("some_lock_key")

  # This won't work
  SimpleMutex::Mutex.unlock!("some_lock_key", signature: "alakazam")

  # This will work because of force: true
  SimpleMutex::Mutex.unlock!("some_lock_key", force: true)

  # This will work because of force: true
  SimpleMutex::Mutex.unlock!("some_lock_key", signature: "alakazam", force: true)
```

You can get signature from instance if you want. By default it is UUID generated by SecureRandom.

```ruby
  mutex = SimpleMutex::Mutex.new("some_lock_key")
  mutex.signature
```

You can provide options like mutex TTL (`:expire`, in milliseconds) and payload
(`payload`, pretty much anything, that can be serialized as JSON'ed, it will be stored in value
of redis record)

```ruby
  mutex = SimpleMutex::Mutex.new("some_lock_key", expire: 2000, payload: { name: "MyCoolLock" })
  mutex.lock!
  # your code
  mutex.unlock!
```

## SimpleMutex::Job Usage

This is class made to simplify usage for locking of sidekiq jobs. It will create lock with
`lock_key` based on job's `class.name` and it's arguments if `lock_with_params: true`.

```ruby
  class SomeJob
    include Sidekiq::Worker

    def perform(*args)
      SimpleMutex::Job.new(
        self,
        params:           args,
        lock_with_params: true,
        mutex_ttl:        1 * 60 * 60,
      ).with_redlock do
        # your code
      end
    end
  end
```

`params` will be used to generate `lock_key` if `lock_with_params: true`.

`mutex_ttl` is in seconds.

## SimpleMutex::Batch Usage

This is wrapper for `Sidekiq::Batch` (from Sidekiq Pro) that helps to prevent running two
similar batches.

```ruby
  batch = SimpleMutex::Batch.new(
      lock_key: "my_batch",
      mutex_options: { expire: 23.hours.to_i * 1000 },
    )

    batch.description = "batch of MyJobs"
    batch.on(:success, self.class, {}) # you can add custom callbacks like with Sidekiq::Batch
    batch.on(:death ,  self.class, {})

    batch.jobs do
      set_of_job_attributes.each do |job_attributes|
        MyJob.perform(job_attributes)
      end
    end
```

`mutex_options` are forwaded to SimpleMutex::Mutex as is. So `expire` is in miliseconds.

## SimpleMutex::JobCleaner Usage

If you use SimpleMutex for locking jobs via `SimpleMutex::Job`, when Sidekiq dies
unexpectedely, there can be leftover mutexes for dead jobs. To delete them you can use:

```ruby
  SimpleMutex::JobCleaner.unlock_dead_jobs
```


## SimpleMutex::BatchCleaner Usage

If you use SimpleMutex for locking Batches via `SimpleMutex::Batch`, when Sidekiq dies
unexpectedely, there can be leftover mutexes for dead batches. To delete them you can use:

```ruby
  SimpleMutex::BatchCleaner.unlock_dead_batches
```

## SimpleMutex::Helper Usage

Getting lock by `lock_key` (returns nil if no such lock)

```ruby
SimpleMutex::Helper.get("some_lock_key")
```

Listing existing locks.

```ruby
SimpleMutex::Helper.list(mode: :default)
```

`mode:` paramater allows to filter locks by type:
* `:all` - all locks including manual
* `:job` - job locks
* `:batch`   - batch locks
* `:default` - job and batch locks

## SimpleMutex::JobMixin Usage

Base Job class

```ruby
class ApplicationJob
  include Sidekiq::Worker
  include SimpleMutex::JobMixin

  class << self
    def inherited(job_class)
      # Setting default timeout for mutex. Can be skipped but then you should
      # set timeout for every child job class with locking! or it will fail.
      job_class.set_job_timeout(5 * 60 * 60) # 5.hours

      job_class.prepend(
        Module.new do
          def perform(*args)
              with_redlock(args) { super }
          end
        end,
      )
    end
  end
end
```

DSL:
 - `locking!` - enables locking with simple_mutex for jobs of this class
 - `lock_with_params!` - locks are specific for set of arguments. Same job with other arguments
can still be called.
 - `skip_locking_error?` - suppresses `SimpleMutex::Mutex::LockError`
 - `set_job_timeout` - redis mutex TTL in seconds (will be removed by redis itself on timeout)

Example:

```ruby
class SpecificJob < ApplicaionJob
  locking!
  lock_with_params!
  set_job_timeout 6 * 60 * 60

  def perform
    # ...
  end
end
```

You can also override error processing for SimpleMutex::Mutex::LockError

```ruby
  # DEFAULT ERROR PROCESSING
  # def process_locking_error(error)
  #   raise error unless self.class.skip_locking_error?
  # end

  class SpecificJob < ApplicaionJob
    locking!

    def perform
      # ...
    end

    def process_locking_error(error)
      SomeLogger.error(error.msg)
      raise error unless self.class.skip_locking_error?
    end
  end
```

## Contributing

Bug reports and pull requests are welcome on GitHub at https://github.com/umbrellio/simple_mutex.

## License

Released under MIT License.

## Authors

Team Umbrellio

---

<a href="https://github.com/umbrellio/">
<img style="float: left;" src="https://umbrellio.github.io/Umbrellio/supported_by_umbrellio.svg" alt="Supported by Umbrellio" width="439" height="72">
</a>